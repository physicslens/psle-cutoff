<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Secondary School PSLE Cut-Off Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js for the graph -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root {
      --bg: #f8fafc;
      --card: #ffffff;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #64748b;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --shadow: 0 10px 28px rgba(15, 23, 42, 0.09);
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at top left, #e0f2fe 0, #f8fafc 45%, #f8fafc 100%);
      color: var(--text);
    }

    .wrap {
      max-width: 1200px;
      margin: 24px auto 40px;
      padding: 0 16px 32px;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0 0 4px;
      letter-spacing: -0.03em;
    }

    .subtitle {
      margin: 0 0 18px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      padding: 16px 18px 18px;
      margin-bottom: 18px;
      backdrop-filter: blur(8px);
    }

    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }

    .flex-grow {
      flex: 1 1 0;
    }

    label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input[type="file"] {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #f9fafb;
      font-size: 0.9rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2);
    }

    .slider-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }

    .slider-group {
      flex: 1 1 220px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .slider-value {
      font-weight: 700;
      color: var(--accent);
      margin-left: 6px;
      font-variant-numeric: tabular-nums;
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: #e5e7eb;
      outline: none;
      transition: background 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    input[type="range"]:hover::-webkit-slider-thumb,
    input[type="range"]:hover::-moz-range-thumb {
      transform: scale(1.08);
      box-shadow: 0 0 0 6px rgba(37, 99, 235, 0.25);
      border-color: #1d4ed8;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .metric {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
    }

    .search-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 8px;
    }

    .search-input-wrap {
      flex: 1 1 200px;
      position: relative;
    }

    .search-input-wrap input {
      width: 100%;
      padding: 7px 10px 7px 26px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 0.82rem;
      background: #f9fafb;
    }

    .search-icon {
      position: absolute;
      left: 9px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      color: var(--muted);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 7px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid transparent;
      cursor: pointer;
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 6px 15px rgba(37, 99, 235, 0.25);
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      white-space: nowrap;
    }

    .btn:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(37, 99, 235, 0.35);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(37, 99, 235, 0.35);
    }

    .btn-outline {
      background: transparent;
      color: var(--accent);
      border-color: var(--accent-soft);
      box-shadow: none;
    }

    .btn-outline:hover {
      background: var(--accent-soft);
      box-shadow: none;
    }

    .year-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e2e8f0;
      font-size: 0.78rem;
      cursor: pointer;
      background: #f9fafb;
      color: var(--muted);
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .chip.active {
      background: #1d4ed8;
      border-color: #1d4ed8;
      color: #eff6ff;
    }

    .table-wrap {
      max-height: 480px;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
    }
    .dual-range {
      position: relative;
      height: 0;
      margin-top: 0;
    }
    .dual-range input[type="range"] {
      position: absolute;
      left: 0;
      right: 0;
      background: transparent;
      opacity: 0;
      pointer-events: none;
    }
    .dual-range input.min { top: 0; }
    .dual-range input.max { top: 16px; }
    .dual-range input.min::-webkit-slider-thumb { border-color: #10b981; }
    .dual-range input.max::-webkit-slider-thumb { border-color: #ef4444; }
    .dual-range input.min::-moz-range-thumb { border-color: #10b981; }
    .dual-range input.max::-moz-range-thumb { border-color: #ef4444; }

    .dual-slider {
      position: relative;
      height: 28px;
      margin-top: 2px;
    }
    .dual-slider-track {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 6px;
      transform: translateY(-50%);
      border-radius: 999px;
      background: #e5e7eb;
    }
    .dual-slider-range {
      position: absolute;
      top: 50%;
      height: 6px;
      transform: translateY(-50%);
      border-radius: 999px;
      background: #cbd5e1;
    }
    .dual-slider-thumb {
      position: absolute;
      top: 50%;
      width: 18px;
      height: 18px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
      cursor: pointer;
    }
    .dual-slider-thumb.min { border-color: #10b981; }
    .dual-slider-thumb.max { border-color: #ef4444; }
    .range-values {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 2px;
    }
    .debug-panel {
      border: 1px dashed var(--border);
      border-radius: 8px;
      padding: 8px;
      background: #f9fafb;
      font-size: 0.78rem;
      max-height: 160px;
      overflow: auto;
    }
    .debug-panel .entry { margin: 2px 0; color: #334155; }

    .chart-wrap {
      height: 400px;
      max-height: 400px;
    }

    .school-checkboxes {
      max-height: 120px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #f9fafb;
      padding: 6px 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px 10px;
      font-size: 0.78rem;
    }

    .school-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      width: 48%;
      min-width: 180px;
    }

    .school-checkbox input {
      margin: 0;
    }




    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.83rem;
    }

    thead {
      background: #f1f5f9;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    th, td {
      padding: 7px 8px;
      border-bottom: 1px solid #e5e7eb;
      text-align: left;
      white-space: nowrap;
    }

    th {
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    th.sortable:hover {
      background: #e5e7eb;
    }

    th .sort-indicator {
      margin-left: 4px;
      font-size: 0.7rem;
      opacity: 0.7;
    }

    tbody tr:nth-child(even) {
      background: #f9fafb;
    }

    tbody tr:hover {
      background: #eff6ff;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.45rem;
      }
      .card {
        padding: 14px 14px 16px;
      }
      .flex-row {
        flex-direction: column;
        align-items: stretch;
      }
      .slider-row {
        flex-direction: column;
      }
      .table-wrap {
        max-height: 360px;
      }
      th, td {
        padding: 6px 6px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Secondary School PSLE Cut-Off Explorer</h1>
    

    <!-- Posting group filters (top) -->
    <div class="card">
      <label>Select Posting Groups</label>
      <div class="search-row" id="pgFiltersTop">
        <label><input type="checkbox" id="topFilterIP" checked> IP</label>
        <label><input type="checkbox" id="topFilterPG3" checked> PG3</label>
        <label><input type="checkbox" id="topFilterPG2" checked> PG2</label>
        <label><input type="checkbox" id="topFilterPG1" checked> PG1</label>
        <label><input type="checkbox" id="topShowAffSplit" checked> Show affiliation</label>
        
      </div>
      
    </div>

    <!-- Search + year chips -->
    <div class="card">
      <label>Find Schools and Years</label>
      <div class="search-row">
        <div class="search-input-wrap">
          <span class="search-icon">üîç</span>
          <input type="text" id="searchInput" placeholder="Filter by school name‚Ä¶" />
        </div>
      </div>

      <div style="margin-top: 8px;">
        <label style="margin-bottom: 4px;">Years in view</label>
        <div class="year-chips" id="yearChips"></div>
      </div>

      <div class="metrics">
        <div class="metric">
          Rows loaded: <span id="metricTotalRows">0</span>
        </div>
        <div class="metric">
          Rows shown: <span id="metricShownRows">0</span>
        </div>
        <div class="metric">
          Years (active): <span id="metricYears">‚Äì</span>
        </div>
      </div>
    </div>

    <!-- Chart: Posting Groups with affiliation split lines -->
    <div class="card">
      <label>Posting Groups by Affiliation</label>
      <p style="font-size: 0.8rem; color: var(--muted); margin-top: 2px;">
        Affiliated lines use solid style; non-affiliated lines use dashed style. The PSLE cohort appears for context.
      </p>
      <div class="chart-wrap">
        <canvas id="trendChart"></canvas>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <label>School Table</label>
      <p style="font-size: 0.8rem; color: var(--muted); margin-top: 2px;">
        Use the checkbox to select schools to display in the chart.
        Click on headers to sort.
      </p>
      <div style="margin-top: 6px;">
        <label style="margin-bottom: 4px;">Cut-off range (table filter)</label>
        <div class="range-values">
          <span>Min: <strong id="cutoffMinValue">‚Äì</strong></span>
          <span>Max: <strong id="cutoffMaxValue">‚Äì</strong></span>
        </div>
        <div class="dual-range">
          <input class="min" type="range" id="cutoffMinSlider" min="0" max="40" value="0" step="1" />
          <input class="max" type="range" id="cutoffMaxSlider" min="0" max="40" value="40" step="1" />
        </div>
        <div class="dual-slider" id="cutoffDualSlider">
          <div class="dual-slider-track"></div>
          <div class="dual-slider-range" id="cutoffRangeFill" style="left:0;width:0"></div>
          <div class="dual-slider-thumb min" id="cutoffThumbMin" style="left:0"></div>
          <div class="dual-slider-thumb max" id="cutoffThumbMax" style="left:100%"></div>
        </div>
      </div>
      <div class="table-wrap">
        <table>
          <thead id="tableHead"></thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // PSLE cohort sizes (students sitting PSLE; almost all proceed to secondary)
    const psleCohortByYear = {
      2022: 37095,
      2023: 38088,
      2024: 40894,
      2025: 37926,
      2026: 37350
    };

    let rawRows = [];
    let filteredRows = [];
    let headers = [];
    let chartAffInstance = null;
    let chartNonAffInstance = null;

    let activeYears = new Set();
    let searchTerm = "";
    let sortState = { key: null, direction: "asc" };
    let selectedSchools = new Set();
    const excludedYears = new Set([2027]);
    // posting groups are shown separately; add group filters
    let activeGroups = new Set(["ip_max", "pg3_max", "pg2_max", "pg1_max"]);
    function updateActiveGroups() {
      activeGroups.clear();
      if (topFilterIP?.checked) activeGroups.add("ip_max");
      if (topFilterPG3?.checked) activeGroups.add("pg3_max");
      if (topFilterPG2?.checked) activeGroups.add("pg2_max");
      if (topFilterPG1?.checked) activeGroups.add("pg1_max");
      if (!activeGroups.size) {
        activeGroups = new Set(["ip_max", "pg3_max", "pg2_max", "pg1_max"]);
        if (topFilterIP) topFilterIP.checked = true;
        if (topFilterPG3) topFilterPG3.checked = true;
        if (topFilterPG2) topFilterPG2.checked = true;
        if (topFilterPG1) topFilterPG1.checked = true;
      }
      
      buildCutoffSlider();
      applyFilter();
    }

    const statusText = document.getElementById("statusText");
    function setStatus(text) { if (statusText) statusText.textContent = text; }
    const tableHead = document.getElementById("tableHead");
    const tableBody = document.getElementById("tableBody");
    const metricTotalRows = document.getElementById("metricTotalRows");
    const metricShownRows = document.getElementById("metricShownRows");
    const metricYears = document.getElementById("metricYears");
    const searchInput = document.getElementById("searchInput");
    const yearChipsContainer = document.getElementById("yearChips");
    // removed download button
    const topFilterIP = document.getElementById("topFilterIP");
    const topFilterPG3 = document.getElementById("topFilterPG3");
    const topFilterPG2 = document.getElementById("topFilterPG2");
    const topFilterPG1 = document.getElementById("topFilterPG1");
    const topShowAffSplit = document.getElementById("topShowAffSplit");
    
    const cutoffMinSlider = document.getElementById("cutoffMinSlider");
    const cutoffMaxSlider = document.getElementById("cutoffMaxSlider");
    const cutoffMinValue = document.getElementById("cutoffMinValue");
    const cutoffMaxValue = document.getElementById("cutoffMaxValue");
    const cutoffDualSlider = document.getElementById("cutoffDualSlider");
    const cutoffRangeFill = document.getElementById("cutoffRangeFill");
    const cutoffThumbMin = document.getElementById("cutoffThumbMin");
    const cutoffThumbMax = document.getElementById("cutoffThumbMax");
    let cutoffMin = null;
    let cutoffMax = null;
    let cutoffMinLimit = null;
    let cutoffMaxLimit = null;

    function toNumber(x) {
      const v = parseFloat(x);
      return Number.isFinite(v) ? v : null;
    }

    function getGroupValue(row, key) {
      const v = toNumber(row[key]);
      return v != null ? v : null;
    }

    function computeCutoffForActiveGroups(row) {
      const keys = [];
      if (activeGroups.has("ip_max")) keys.push("ip_max");
      if (activeGroups.has("pg3_max")) keys.push("pg3_max");
      if (activeGroups.has("pg2_max")) keys.push("pg2_max");
      if (activeGroups.has("pg1_max")) keys.push("pg1_max");
      let best = null;
      for (const k of keys) {
        const v = toNumber(row[k]);
        if (v != null) best = best == null ? v : Math.max(best, v);
      }
      return best;
    }

    function rowHasValueInRange(row, min, max) {
      const keys = [];
      if (activeGroups.has("ip_max")) keys.push("ip_max");
      if (activeGroups.has("pg3_max")) keys.push("pg3_max");
      if (activeGroups.has("pg2_max")) keys.push("pg2_max");
      if (activeGroups.has("pg1_max")) keys.push("pg1_max");
      for (const k of keys) {
        const v = toNumber(row[k]);
        if (v != null && v >= min && v <= max) return true;
      }
      return false;
    }

    function buildCutoffSlider() {
      const values = rawRows
        .map((r) => computeCutoffForActiveGroups(r))
        .filter((v) => v != null);
      if (!values.length) {
        if (cutoffMinSlider) cutoffMinSlider.disabled = true;
        if (cutoffMaxSlider) cutoffMaxSlider.disabled = true;
        if (cutoffMinValue) cutoffMinValue.textContent = "‚Äì";
        if (cutoffMaxValue) cutoffMaxValue.textContent = "‚Äì";
        cutoffMin = cutoffMax = cutoffMinLimit = cutoffMaxLimit = null;
        return;
      }
      const min = Math.floor(Math.min(...values));
      const max = Math.ceil(Math.max(...values));
      cutoffMinSlider.min = min;
      cutoffMinSlider.max = max;
      cutoffMaxSlider.min = min;
      cutoffMaxSlider.max = max;
      cutoffMinSlider.value = min;
      cutoffMaxSlider.value = max;
      cutoffMinSlider.disabled = false;
      cutoffMaxSlider.disabled = false;
      cutoffMinValue.textContent = min;
      cutoffMaxValue.textContent = max;
      cutoffMinLimit = min;
      cutoffMaxLimit = max;
      cutoffMin = min;
      cutoffMax = max;
      updateDualSliderFromValues();
    }

    function valueToPercent(v) {
      if (cutoffMinLimit == null || cutoffMaxLimit == null) return 0;
      const span = cutoffMaxLimit - cutoffMinLimit;
      if (span <= 0) return 0;
      return ((v - cutoffMinLimit) / span) * 100;
    }

    function percentToValue(p) {
      if (cutoffMinLimit == null || cutoffMaxLimit == null) return cutoffMinLimit ?? 0;
      const span = cutoffMaxLimit - cutoffMinLimit;
      return Math.round(cutoffMinLimit + (p / 100) * span);
    }

    function updateDualSliderFromValues() {
      if (!cutoffDualSlider) return;
      const pMin = valueToPercent(cutoffMin);
      const pMax = valueToPercent(cutoffMax);
      cutoffThumbMin.style.left = pMin + "%";
      cutoffThumbMax.style.left = pMax + "%";
      cutoffRangeFill.style.left = Math.min(pMin, pMax) + "%";
      cutoffRangeFill.style.width = Math.abs(pMax - pMin) + "%";
      if (cutoffMinValue) cutoffMinValue.textContent = cutoffMin;
      if (cutoffMaxValue) cutoffMaxValue.textContent = cutoffMax;
    }

    function bindDualSlider() {
      if (!cutoffDualSlider) return;
      let dragging = null;
      const onMove = (clientX) => {
        const rect = cutoffDualSlider.getBoundingClientRect();
        const p = Math.min(100, Math.max(0, ((clientX - rect.left) / rect.width) * 100));
        const v = percentToValue(p);
        if (dragging === "min") {
          cutoffMin = Math.min(v, cutoffMax);
        } else if (dragging === "max") {
          cutoffMax = Math.max(v, cutoffMin);
        }
        cutoffMinSlider.value = cutoffMin;
        cutoffMaxSlider.value = cutoffMax;
        updateDualSliderFromValues();
        applyFilter();
      };
      const onMouseMove = (e) => onMove(e.clientX);
      const onTouchMove = (e) => onMove(e.touches[0].clientX);
      const stopDrag = () => {
        dragging = null;
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onTouchMove);
        window.removeEventListener("mouseup", stopDrag);
        window.removeEventListener("touchend", stopDrag);
      };
      const startDrag = (type) => (e) => {
        dragging = type;
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("mouseup", stopDrag);
        window.addEventListener("touchend", stopDrag);
        if (e.type === "mousedown") onMove(e.clientX);
        if (e.type === "touchstart") onMove(e.touches[0].clientX);
      };
      cutoffThumbMin.addEventListener("mousedown", startDrag("min"));
      cutoffThumbMin.addEventListener("touchstart", startDrag("min"));
      cutoffThumbMax.addEventListener("mousedown", startDrag("max"));
      cutoffThumbMax.addEventListener("touchstart", startDrag("max"));
      cutoffDualSlider.addEventListener("mousedown", (e) => {
        const rect = cutoffDualSlider.getBoundingClientRect();
        const p = Math.min(100, Math.max(0, ((e.clientX - rect.left) / rect.width) * 100));
        const v = percentToValue(p);
        const distMin = Math.abs(v - cutoffMin);
        const distMax = Math.abs(v - cutoffMax);
        dragging = distMin <= distMax ? "min" : "max";
        startDrag(dragging)(e);
      });
    }

    function enableInputs() {
      searchInput.disabled = false;
    }

    function buildYearChips() {
      yearChipsContainer.innerHTML = "";
      const yearsInData = Array.from(
        new Set([
          ...rawRows.map((r) => r.year).filter((y) => y != null),
          ...Object.keys(psleCohortByYear).map((y) => parseInt(y, 10) + 1)
        ])
      ).filter((y) => !excludedYears.has(y)).sort((a, b) => a - b);

      if (!yearsInData.length) return;

      // If activeYears is empty (initial load), activate all
      if (!activeYears.size) {
        yearsInData.forEach((y) => activeYears.add(y));
      }

      yearsInData.forEach((year) => {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "chip" + (activeYears.has(year) ? " active" : "");
        chip.textContent = year;
        chip.dataset.year = year;
        chip.addEventListener("click", () => {
          if (activeYears.has(year)) {
            activeYears.delete(year);
          } else {
            activeYears.add(year);
          }
          // if all toggled off, re-enable all (to avoid empty state confusion)
          if (!activeYears.size) {
            yearsInData.forEach((y) => activeYears.add(y));
          }
          applyFilter();
        });
        yearChipsContainer.appendChild(chip);
      });
    }

    // Selection happens via table checkboxes


    function applyFilter() {
      if (!rawRows.length) return;

      const activeYearList = Array.from(activeYears);
      let rangeMin = cutoffMinSlider ? parseFloat(cutoffMinSlider.value) : null;
      let rangeMax = cutoffMaxSlider ? parseFloat(cutoffMaxSlider.value) : null;
      if (rangeMin != null && rangeMax != null && rangeMin > rangeMax) {
        const tmp = rangeMin;
        rangeMin = rangeMax;
        rangeMax = tmp;
      }
      if (rangeMin != null && cutoffMinValue) cutoffMinValue.textContent = Math.floor(rangeMin);
      if (rangeMax != null && cutoffMaxValue) cutoffMaxValue.textContent = Math.ceil(rangeMax);

      filteredRows = rawRows.filter((r) => {
        if (r.year != null && activeYearList.length) {
          if (!activeYears.has(r.year)) return false;
        }

        if (searchTerm) {
          const school = (r.school || "").toString().toLowerCase();
          if (!school.includes(searchTerm)) return false;
        }

        if (rangeMin != null && rangeMax != null) {
          if (!rowHasValueInRange(r, rangeMin, rangeMax)) return false;
        }

        return true;
      });

      // Keep selectedSchools only for schools present after filtering
      const filteredSchoolSet = new Set(
        filteredRows.map((r) => r.school).filter((s) => s && s.trim().length)
      );
      for (const s of Array.from(selectedSchools)) {
        if (!filteredSchoolSet.has(s)) selectedSchools.delete(s);
      }

      applySort();
      renderTable();
      updateMetrics();
      updateChart();
      updateYearChipsActiveState();
    }

    function updateYearChipsActiveState() {
      const chips = yearChipsContainer.querySelectorAll(".chip");
      chips.forEach((chip) => {
        const year = parseInt(chip.dataset.year, 10);
        if (activeYears.has(year)) chip.classList.add("active");
        else chip.classList.remove("active");
      });
    }

    function applySort() {
      if (!sortState.key) return;
      const { key, direction } = sortState;

      filteredRows.sort((a, b) => {
        let av = a[key];
        let bv = b[key];

        const an = toNumber(av);
        const bn = toNumber(bv);
        const bothNumeric = an != null && bn != null;

        if (bothNumeric) {
          av = an;
          bv = bn;
        } else {
          av = av == null ? "" : String(av).toLowerCase();
          bv = bv == null ? "" : String(bv).toLowerCase();
        }

        if (av < bv) return direction === "asc" ? -1 : 1;
        if (av > bv) return direction === "asc" ? 1 : -1;
        return 0;
      });
    }

    function renderTable() {
      tableHead.innerHTML = "";
      tableBody.innerHTML = "";

      if (!filteredRows.length) return;

      const groupKeys = ["ip_max", "pg3_max", "pg2_max", "pg1_max"];
      const nonGroupHeaders = headers.filter((h) => !groupKeys.includes(h) && !/_min$/.test(h) && h !== "table_index");
      const visibleGroupHeaders = groupKeys.filter((k) => activeGroups.has(k) && headers.includes(k));
      const allHeaders = ["select", ...nonGroupHeaders, ...visibleGroupHeaders];

      const headRow = document.createElement("tr");
      allHeaders.forEach((h) => {
        const th = document.createElement("th");
        th.textContent = h === "select" ? "Select" : h;
        th.classList.add("sortable");

        const indicator = document.createElement("span");
        indicator.className = "sort-indicator";
        if (sortState.key === h) {
          indicator.textContent = sortState.direction === "asc" ? "‚ñ≤" : "‚ñº";
        } else {
          indicator.textContent = "";
        }
        th.appendChild(indicator);

        if (h !== "select") {
          th.addEventListener("click", () => {
            if (sortState.key === h) {
              sortState.direction = sortState.direction === "asc" ? "desc" : "asc";
            } else {
              sortState.key = h;
              sortState.direction = "asc";
            }
            applySort();
            renderTable();
          });
        }

        headRow.appendChild(th);
      });
      tableHead.appendChild(headRow);

      filteredRows.forEach((r) => {
        const tr = document.createElement("tr");
        allHeaders.forEach((h) => {
          const td = document.createElement("td");
          if (h === "select") {
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = selectedSchools.has(r.school);
            cb.addEventListener("change", () => {
              if (cb.checked) selectedSchools.add(r.school);
              else selectedSchools.delete(r.school);
              // reflect the change across any duplicate rows of the same school
              const checkboxes = tableBody.querySelectorAll('input[type="checkbox"]');
              checkboxes.forEach((el) => {
                const row = el.closest('tr');
                const schoolCellIndex = allHeaders.indexOf("school");
                if (schoolCellIndex !== -1) {
                  const sc = row.children[schoolCellIndex]?.textContent;
                  if (sc === r.school) el.checked = cb.checked;
                }
              });
              updateChart();
            });
            td.appendChild(cb);
          } else {
            let value = r[h];
            td.textContent = value == null ? "" : value;
          }
          tr.appendChild(td);
        });
        tableBody.appendChild(tr);
      });
    }

    function updateMetrics() {
      metricTotalRows.textContent = rawRows.length;
      metricShownRows.textContent = filteredRows.length;

      const years = Array.from(
        new Set(filteredRows.map((r) => r.year).filter((y) => y != null))
      ).sort((a, b) => a - b);

      metricYears.textContent = years.length ? years.join(", ") : "‚Äì";
    }


    function updateChart() {
      if (chartAffInstance) { chartAffInstance.destroy(); chartAffInstance = null; }
      if (chartNonAffInstance) { chartNonAffInstance.destroy(); chartNonAffInstance = null; }

      // Determine years in filtered rows that are active will be computed below

      const getColorForIndex = (i) => `hsl(${(i * 57) % 360} 80% 45%)`;
      const hueForString = (s) => {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = (h * 31 + s.charCodeAt(i)) % 360;
        }
        return h;
      };
      const colorForDataset = (schoolName, key, aff) => {
        const base = `${schoolName}|${key}|${aff ? "aff" : "non"}`;
        const hue = hueForString(base);
        return `hsl(${hue} 85% 45%)`;
      };
      const alphaizeHsl = (c, a) => c.startsWith("hsl(") ? c.replace(")", ` / ${a})`) : c;
      const buildDatasetsForKey = (key) => {
        const datasets = [];
        const groupLabelsMap = { pg1_max: "PG1", pg2_max: "PG2", pg3_max: "PG3", ip_max: "IP" };
        const groupLabel = groupLabelsMap[key] || key;
        const schoolsToPlot = Array.from(selectedSchools);
        schoolsToPlot.forEach((schoolName, idx) => {
          const data = years.map((year) => {
            const rows = rawRows.filter((r) => r.school === schoolName && r.year === year);
            const vals = rows
              .map((r) => getGroupValue(r, key))
              .filter((v) => v != null);
            if (!vals.length) return null;
            return Math.max(...vals);
          });
          if (data.some((v) => v != null)) {
            const c = getColorForIndex(idx);
            datasets.push({
              label: `${schoolName} (${groupLabel})`,
              data,
              yAxisID: "yCutoff",
              tension: 0,
              borderColor: c,
              pointBackgroundColor: c,
              pointBorderColor: c,
              borderWidth: 3,
              pointRadius: 6,
              pointHoverRadius: 8,
              spanGaps: true,
              fill: false
            });
          }
        });
        return datasets;
      };

      const cfg = {
        type: "line",
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          scales: {
            x: { title: { display: true, text: "Year" } },
            yCutoff: {
              type: "linear",
              position: "left",
              title: { display: true, text: "Cut-off (AL score)" },
              ticks: { stepSize: 1 }
            },
            yCohort: {
              type: "linear",
              position: "right",
              title: { display: true, text: "PSLE cohort" },
              grid: { drawOnChartArea: false }
            }
          },
          plugins: {
            legend: { position: "bottom" },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const label = ctx.dataset.label || "";
                  const v = ctx.parsed.y;
                  if (v == null) return label;
                  if (ctx.dataset.yAxisID === "yCohort") {
                    const yr = ctx.chart.data.labels[ctx.dataIndex];
                    return `${yr} PSLE cohort: ${v.toLocaleString()}`;
                  }
                  return `${label}: ${v.toFixed(0)}`;
                }
              }
            }
          }
        }
      };

      const yearsFromRows = Array.from(new Set(rawRows.map((r) => r.year).filter((y) => y != null)));
      const yearsFromCohortIntake = Object.keys(psleCohortByYear).map((y) => parseInt(y, 10) + 1);
      const years = Array.from(new Set([...yearsFromRows, ...yearsFromCohortIntake]))
        .filter((y) => activeYears.has(y) && !excludedYears.has(y))
        .sort((a, b) => a - b);

      if (!years.length) return;

      const canvas = document.getElementById("trendChart");
      if (!canvas) return;
      const existing = Chart.getChart(canvas);
      if (existing) existing.destroy();
      const ctx = canvas.getContext("2d");
      const keysToPlot = [];
      if (activeGroups.has("ip_max")) keysToPlot.push("ip_max");
      if (activeGroups.has("pg1_max")) keysToPlot.push("pg1_max");
      if (activeGroups.has("pg2_max")) keysToPlot.push("pg2_max");
      if (activeGroups.has("pg3_max")) keysToPlot.push("pg3_max");
      const showAffSplit = topShowAffSplit ? topShowAffSplit.checked : true;
      const buildDatasetsForKeyAff = (key, aff) => {
        const datasets = [];
        const schoolsToPlot = Array.from(selectedSchools);
        schoolsToPlot.forEach((schoolName, idx) => {
          const data = years.map((year) => {
            const rows = rawRows.filter((r) => r.school === schoolName && r.year === year);
            const vals = rows
              .filter((r) => {
                const stream = (r.stream ?? r.affiliated ?? r.is_affiliated ?? r.affiliation ?? "").toString().toLowerCase();
                const isAff = stream === "affiliated" || stream === "aff" || stream === "a" || stream === "true" || stream === "yes" || stream === "1";
                return aff ? isAff : !isAff;
              })
              .map((r) => getGroupValue(r, key))
              .filter((v) => v != null);
            if (!vals.length) return null;
            return Math.max(...vals);
          });
          if (data.some((v) => v != null)) {
            const c = colorForDataset(schoolName, key, aff);
            const cStroke = alphaizeHsl(c, 0.55);
            datasets.push({
              label: `${schoolName} (${({ pg1_max:"PG1", pg2_max:"PG2", pg3_max:"PG3", ip_max:"IP" })[key] || key}, ${aff ? "Affiliated" : "Non-affiliated"})`,
              data,
              yAxisID: "yCutoff",
              tension: 0,
              borderColor: cStroke,
              pointBackgroundColor: alphaizeHsl(c, 0.55),
              pointBorderColor: alphaizeHsl(c, 0.55),
              borderWidth: 3,
              pointRadius: 6,
              pointHoverRadius: 8,
              spanGaps: true,
              fill: false,
              borderDash: aff ? undefined : [6, 6]
            });
          }
        });
        return datasets;
      };
      let plottedDatasets = [];
      if (showAffSplit) {
        plottedDatasets = keysToPlot.flatMap((k) => buildDatasetsForKeyAff(k, true));
      } else {
        plottedDatasets = keysToPlot.flatMap((k) => buildDatasetsForKeyAff(k, false));
      }

      const allValues = plottedDatasets
        .flatMap((ds) => ds.data)
        .filter((v) => v != null);
      if (allValues.length) {
        const vmin = Math.min(...allValues);
        const vmax = Math.max(...allValues);
        const pad = 1;
        cfg.options.scales.yCutoff.min = Math.max(1, Math.floor(vmin - pad));
        cfg.options.scales.yCutoff.max = Math.ceil(vmax + pad);
      } else {
        cfg.options.scales.yCutoff.min = 4;
        cfg.options.scales.yCutoff.max = 30;
      }

      const cohortData = years.map((y) => psleCohortByYear[y - 1] ?? null);
      const intakeDataset = {
        label: "PSLE cohort",
        data: cohortData,
        yAxisID: "yCohort",
        tension: 0,
        borderDash: [4, 4],
        borderColor: "#334155",
        pointBackgroundColor: "#334155",
        borderWidth: 2,
        pointRadius: 4,
        pointHoverRadius: 6
      };

      const combinedDatasets = plottedDatasets.concat([intakeDataset]);
      chartInstance = new Chart(ctx, { ...cfg, data: { labels: years, datasets: combinedDatasets } });
    }

    function downloadFilteredCsv() {
      if (!filteredRows.length) return;

      const allHeaders = Array.from(new Set([...headers]));
      const rows = filteredRows.map((r) => {
        const obj = {};
        allHeaders.forEach((h) => {
          let v = r[h];
          obj[h] = v == null ? "" : v;
        });
        return obj;
      });

      const csv = Papa.unparse(rows, { columns: allHeaders });
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const now = new Date();
      const ts = now.toISOString().slice(0, 10);
      link.href = url;
      link.download = `filtered_psle_cutoff_${ts}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }



    function loadDefaultCsv() {
      setStatus("Loading data‚Ä¶");
      fetch("secondary_psle_cutoff.csv")
        .then((res) => {
          if (!res.ok) {
            throw new Error("Failed to fetch secondary_psle_cutoff.csv");
          }
          return res.text();
        })
        .then((text) => {
          const results = Papa.parse(text, {
            header: true,
            skipEmptyLines: true
          });
          const rows = results.data;
          if (!rows.length) {
            setStatus("No rows found in CSV");
            return;
          }

          headers = results.meta.fields || Object.keys(rows[0]);

          rawRows = rows.map((r) => {
            const row = { ...r };
            if (row.year !== undefined) {
              const yr = parseInt(row.year, 10);
              row.year = Number.isFinite(yr) ? yr : null;
            } else {
              row.year = null;
            }

            ["ip_max", "pg3_max", "pg2_max", "pg1_max"].forEach((k) => {
              if (row[k] !== undefined && row[k] !== null && row[k] !== "") {
                row[k] = toNumber(row[k]);
              }
            });

            // no aggregated cutoff stored; charts read per posting group
            return row;
          });

          setStatus(`Loaded ${rawRows.length} rows`);
          enableInputs();
          buildYearChips();
          buildCutoffSlider();
          filteredRows = [...rawRows];
          applySort();
          renderTable();
          updateMetrics();
          updateChart();
        })
        .catch((err) => {
          console.error(err);
          setStatus("Error loading CSV");
          if (typeof window.debugLog === "function") {
            window.debugLog("loadDefaultCsv error", String(err));
          } else {
            try { console.log("[DEBUG] loadDefaultCsv error", String(err)); } catch (e) {}
          }
        });
    }

    document.addEventListener("DOMContentLoaded", () => { loadDefaultCsv(); bindDualSlider(); });

    searchInput.addEventListener("input", (e) => {
      searchTerm = e.target.value.trim().toLowerCase();
      applyFilter();
    });

    // removed CSV download button
    topFilterIP?.addEventListener("change", updateActiveGroups);
    topFilterPG3?.addEventListener("change", updateActiveGroups);
    topFilterPG2?.addEventListener("change", updateActiveGroups);
    topFilterPG1?.addEventListener("change", updateActiveGroups);
    topShowAffSplit?.addEventListener("change", updateChart);
    cutoffMinSlider?.addEventListener("input", applyFilter);
    cutoffMaxSlider?.addEventListener("input", applyFilter);
  </script>
</body>
</html>
   
