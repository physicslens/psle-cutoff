<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Secondary School PSLE Cut-Off Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js for the graph -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root {
      --bg: #f8fafc;
      --card: #ffffff;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #64748b;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --shadow: 0 10px 28px rgba(15, 23, 42, 0.09);
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at top left, #e0f2fe 0, #f8fafc 45%, #f8fafc 100%);
      color: var(--text);
    }

    .wrap {
      max-width: 1200px;
      margin: 24px auto 40px;
      padding: 0 16px 32px;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0 0 4px;
      letter-spacing: -0.03em;
    }

    .subtitle {
      margin: 0 0 18px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      padding: 16px 18px 18px;
      margin-bottom: 18px;
      backdrop-filter: blur(8px);
    }

    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }

    .flex-grow {
      flex: 1 1 0;
    }

    label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input[type="file"] {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #f9fafb;
      font-size: 0.9rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2);
    }

    .slider-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }

    .slider-group {
      flex: 1 1 220px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .slider-value {
      font-weight: 700;
      color: var(--accent);
      margin-left: 6px;
      font-variant-numeric: tabular-nums;
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: #e5e7eb;
      outline: none;
      transition: background 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    input[type="range"]:hover::-webkit-slider-thumb,
    input[type="range"]:hover::-moz-range-thumb {
      transform: scale(1.08);
      box-shadow: 0 0 0 6px rgba(37, 99, 235, 0.25);
      border-color: #1d4ed8;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .metric {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
    }

    .search-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 8px;
    }

    .search-input-wrap {
      flex: 1 1 200px;
      position: relative;
    }

    .search-input-wrap input {
      width: 100%;
      padding: 7px 10px 7px 26px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 0.82rem;
      background: #f9fafb;
    }

    .search-icon {
      position: absolute;
      left: 9px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      color: var(--muted);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 7px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid transparent;
      cursor: pointer;
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 6px 15px rgba(37, 99, 235, 0.25);
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      white-space: nowrap;
    }

    .btn:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(37, 99, 235, 0.35);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(37, 99, 235, 0.35);
    }

    .btn-outline {
      background: transparent;
      color: var(--accent);
      border-color: var(--accent-soft);
      box-shadow: none;
    }

    .btn-outline:hover {
      background: var(--accent-soft);
      box-shadow: none;
    }

    .year-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e2e8f0;
      font-size: 0.78rem;
      cursor: pointer;
      background: #f9fafb;
      color: var(--muted);
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .chip.active {
      background: #1d4ed8;
      border-color: #1d4ed8;
      color: #eff6ff;
    }

    .table-wrap {
      max-height: 480px;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .chart-wrap {
      height: 400px;
      max-height: 400px;
    }

    .school-checkboxes {
      max-height: 120px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #f9fafb;
      padding: 6px 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px 10px;
      font-size: 0.78rem;
    }

    .school-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      width: 48%;
      min-width: 180px;
    }

    .school-checkbox input {
      margin: 0;
    }




    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.83rem;
    }

    thead {
      background: #f1f5f9;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    th, td {
      padding: 7px 8px;
      border-bottom: 1px solid #e5e7eb;
      text-align: left;
      white-space: nowrap;
    }

    th {
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    th.sortable:hover {
      background: #e5e7eb;
    }

    th .sort-indicator {
      margin-left: 4px;
      font-size: 0.7rem;
      opacity: 0.7;
    }

    tbody tr:nth-child(even) {
      background: #f9fafb;
    }

    tbody tr:hover {
      background: #eff6ff;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.45rem;
      }
      .card {
        padding: 14px 14px 16px;
      }
      .flex-row {
        flex-direction: column;
        align-items: stretch;
      }
      .slider-row {
        flex-direction: column;
      }
      .table-wrap {
        max-height: 360px;
      }
      th, td {
        padding: 6px 6px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Secondary School PSLE Cut-Off Explorer</h1>
    <p class="subtitle">
      Load your <code>secondary_psle_cutoff.csv</code>, search by school name,
      sort columns, and compare school cut-off with PSLE cohort size.
    </p>

    <!-- Posting group filters (top) -->
    <div class="card">
      <label>Posting group filters</label>
      <div class="search-row" id="pgFiltersTop">
        <label><input type="checkbox" id="topFilterIP" checked> IP</label>
        <label><input type="checkbox" id="topFilterPG3" checked> PG3</label>
        <label><input type="checkbox" id="topFilterPG2" checked> PG2</label>
        <label><input type="checkbox" id="topFilterPG1" checked> PG1</label>
      </div>
    </div>

    <!-- Search + year chips -->
    <div class="card">
      <label>2. Search & years</label>
      <div class="search-row">
        <div class="search-input-wrap">
          <span class="search-icon">üîç</span>
          <input type="text" id="searchInput" placeholder="Filter by school name‚Ä¶" />
        </div>
      </div>

      <div style="margin-top: 8px;">
        <label style="margin-bottom: 4px;">Years in view</label>
        <div class="year-chips" id="yearChips"></div>
      </div>

      <div class="metrics">
        <div class="metric">
          Rows loaded: <span id="metricTotalRows">0</span>
        </div>
        <div class="metric">
          Rows shown: <span id="metricShownRows">0</span>
        </div>
        <div class="metric">
          Years (active): <span id="metricYears">‚Äì</span>
        </div>
      </div>
    </div>

    <!-- Chart: Posting Groups combined -->
    <div class="card">
      <label>3. Posting Groups ‚Äî combined chart</label>
      <p style="font-size: 0.8rem; color: var(--muted); margin-top: 2px;">
        Shows PG1, PG2, PG3 cut-offs together on the same axes per selected school and active years,
        with Sec 1 intake for context.
      </p>
      <div class="chart-wrap">
        <canvas id="trendChart"></canvas>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <label>4. School list</label>
      <p style="font-size: 0.8rem; color: var(--muted); margin-top: 2px;">
        Use the checkbox to select schools to display in the chart.
        Includes computed column <code>computed_max_cutoff</code>.
        Click on headers to sort.
      </p>
      <div class="table-wrap">
        <table>
          <thead id="tableHead"></thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // PSLE cohort sizes (students sitting PSLE; almost all proceed to secondary)
    const psleCohortByYear = {
      2022: 37095,
      2023: 38088,
      2024: 40894,
      2025: 37926,
      2026: 37350
    };

    let rawRows = [];
    let filteredRows = [];
    let headers = [];
    let chartInstance = null;

    let activeYears = new Set();
    let searchTerm = "";
    let sortState = { key: null, direction: "asc" };
    let selectedSchools = new Set();
    const excludedYears = new Set([2027]);
    // posting groups are shown separately; add group filters
    let activeGroups = new Set(["ip_max", "pg3_max", "pg2_max", "pg1_max"]);
    function updateActiveGroups() {
      activeGroups.clear();
      if (topFilterIP?.checked) activeGroups.add("ip_max");
      if (topFilterPG3?.checked) activeGroups.add("pg3_max");
      if (topFilterPG2?.checked) activeGroups.add("pg2_max");
      if (topFilterPG1?.checked) activeGroups.add("pg1_max");
      if (!activeGroups.size) {
        activeGroups = new Set(["ip_max", "pg3_max", "pg2_max", "pg1_max"]);
        if (topFilterIP) topFilterIP.checked = true;
        if (topFilterPG3) topFilterPG3.checked = true;
        if (topFilterPG2) topFilterPG2.checked = true;
        if (topFilterPG1) topFilterPG1.checked = true;
      }
      updateChart();
    }

    const statusText = document.getElementById("statusText");
    function setStatus(text) { if (statusText) statusText.textContent = text; }
    const tableHead = document.getElementById("tableHead");
    const tableBody = document.getElementById("tableBody");
    const metricTotalRows = document.getElementById("metricTotalRows");
    const metricShownRows = document.getElementById("metricShownRows");
    const metricYears = document.getElementById("metricYears");
    const searchInput = document.getElementById("searchInput");
    const yearChipsContainer = document.getElementById("yearChips");
    // removed download button
    const topFilterIP = document.getElementById("topFilterIP");
    const topFilterPG3 = document.getElementById("topFilterPG3");
    const topFilterPG2 = document.getElementById("topFilterPG2");
    const topFilterPG1 = document.getElementById("topFilterPG1");

    function toNumber(x) {
      const v = parseFloat(x);
      return Number.isFinite(v) ? v : null;
    }

    function getGroupValue(row, key) {
      const v = toNumber(row[key]);
      return v != null ? v : null;
    }

    function enableInputs() {
      searchInput.disabled = false;
    }

    function buildYearChips() {
      yearChipsContainer.innerHTML = "";
      const yearsInData = Array.from(
        new Set([
          ...rawRows.map((r) => r.year).filter((y) => y != null),
          ...Object.keys(psleCohortByYear).map((y) => parseInt(y, 10) + 1)
        ])
      ).filter((y) => !excludedYears.has(y)).sort((a, b) => a - b);

      if (!yearsInData.length) return;

      // If activeYears is empty (initial load), activate all
      if (!activeYears.size) {
        yearsInData.forEach((y) => activeYears.add(y));
      }

      yearsInData.forEach((year) => {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "chip" + (activeYears.has(year) ? " active" : "");
        chip.textContent = year;
        chip.dataset.year = year;
        chip.addEventListener("click", () => {
          if (activeYears.has(year)) {
            activeYears.delete(year);
          } else {
            activeYears.add(year);
          }
          // if all toggled off, re-enable all (to avoid empty state confusion)
          if (!activeYears.size) {
            yearsInData.forEach((y) => activeYears.add(y));
          }
          applyFilter();
        });
        yearChipsContainer.appendChild(chip);
      });
    }

    // Selection happens via table checkboxes


    function applyFilter() {
      if (!rawRows.length) return;

      const activeYearList = Array.from(activeYears);

      filteredRows = rawRows.filter((r) => {
        if (r.year != null && activeYearList.length) {
          if (!activeYears.has(r.year)) return false;
        }

        if (searchTerm) {
          const school = (r.school || "").toString().toLowerCase();
          if (!school.includes(searchTerm)) return false;
        }

        return true;
      });

      // Keep selectedSchools only for schools present after filtering
      const filteredSchoolSet = new Set(
        filteredRows.map((r) => r.school).filter((s) => s && s.trim().length)
      );
      for (const s of Array.from(selectedSchools)) {
        if (!filteredSchoolSet.has(s)) selectedSchools.delete(s);
      }

      applySort();
      renderTable();
      updateMetrics();
      updateChart();
      updateYearChipsActiveState();
    }

    function updateYearChipsActiveState() {
      const chips = yearChipsContainer.querySelectorAll(".chip");
      chips.forEach((chip) => {
        const year = parseInt(chip.dataset.year, 10);
        if (activeYears.has(year)) chip.classList.add("active");
        else chip.classList.remove("active");
      });
    }

    function applySort() {
      if (!sortState.key) return;
      const { key, direction } = sortState;

      filteredRows.sort((a, b) => {
        let av = a[key];
        let bv = b[key];

        const an = toNumber(av);
        const bn = toNumber(bv);
        const bothNumeric = an != null && bn != null;

        if (bothNumeric) {
          av = an;
          bv = bn;
        } else {
          av = av == null ? "" : String(av).toLowerCase();
          bv = bv == null ? "" : String(bv).toLowerCase();
        }

        if (av < bv) return direction === "asc" ? -1 : 1;
        if (av > bv) return direction === "asc" ? 1 : -1;
        return 0;
      });
    }

    function renderTable() {
      tableHead.innerHTML = "";
      tableBody.innerHTML = "";

      if (!filteredRows.length) return;

      const allHeaders = ["select", ...Array.from(new Set([...headers]))];

      const headRow = document.createElement("tr");
      allHeaders.forEach((h) => {
        const th = document.createElement("th");
        th.textContent = h === "select" ? "Select" : h;
        th.classList.add("sortable");

        const indicator = document.createElement("span");
        indicator.className = "sort-indicator";
        if (sortState.key === h) {
          indicator.textContent = sortState.direction === "asc" ? "‚ñ≤" : "‚ñº";
        } else {
          indicator.textContent = "";
        }
        th.appendChild(indicator);

        if (h !== "select") {
          th.addEventListener("click", () => {
            if (sortState.key === h) {
              sortState.direction = sortState.direction === "asc" ? "desc" : "asc";
            } else {
              sortState.key = h;
              sortState.direction = "asc";
            }
            applySort();
            renderTable();
          });
        }

        headRow.appendChild(th);
      });
      tableHead.appendChild(headRow);

      filteredRows.forEach((r) => {
        const tr = document.createElement("tr");
        allHeaders.forEach((h) => {
          const td = document.createElement("td");
          if (h === "select") {
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = selectedSchools.has(r.school);
            cb.addEventListener("change", () => {
              if (cb.checked) selectedSchools.add(r.school);
              else selectedSchools.delete(r.school);
              // reflect the change across any duplicate rows of the same school
              const checkboxes = tableBody.querySelectorAll('input[type="checkbox"]');
              checkboxes.forEach((el) => {
                const row = el.closest('tr');
                const schoolCellIndex = allHeaders.indexOf("school");
                if (schoolCellIndex !== -1) {
                  const sc = row.children[schoolCellIndex]?.textContent;
                  if (sc === r.school) el.checked = cb.checked;
                }
              });
              updateChart();
            });
            td.appendChild(cb);
          } else {
            let value = r[h];
            td.textContent = value == null ? "" : value;
          }
          tr.appendChild(td);
        });
        tableBody.appendChild(tr);
      });
    }

    function updateMetrics() {
      metricTotalRows.textContent = rawRows.length;
      metricShownRows.textContent = filteredRows.length;

      const years = Array.from(
        new Set(filteredRows.map((r) => r.year).filter((y) => y != null))
      ).sort((a, b) => a - b);

      metricYears.textContent = years.length ? years.join(", ") : "‚Äì";
    }


    function updateChart() {
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }

      // Determine years in filtered rows that are active will be computed below

      const getColorForIndex = (i) => `hsl(${(i * 57) % 360} 80% 45%)`;
      const buildDatasetsForKey = (key) => {
        const datasets = [];
        const groupLabelsMap = { pg1_max: "PG1", pg2_max: "PG2", pg3_max: "PG3", ip_max: "IP" };
        const groupLabel = groupLabelsMap[key] || key;
        const schoolsToPlot = Array.from(selectedSchools);
        schoolsToPlot.forEach((schoolName, idx) => {
          const data = years.map((year) => {
            const rows = filteredRows.filter((r) => r.school === schoolName && r.year === year);
            const vals = rows.map((r) => getGroupValue(r, key)).filter((v) => v != null);
            if (!vals.length) return null;
            return Math.max(...vals);
          });
          if (data.some((v) => v != null)) {
            datasets.push({
              label: `${schoolName} (${groupLabel})`,
              data,
              yAxisID: "yCutoff",
              tension: 0.25,
              borderColor: getColorForIndex(idx),
              pointBackgroundColor: getColorForIndex(idx),
              pointBorderColor: getColorForIndex(idx),
              borderWidth: 3,
              pointRadius: 6,
              pointHoverRadius: 8,
              spanGaps: true,
              fill: false
            });
          }
        });
        return datasets;
      };

      const cfg = {
        type: "line",
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          scales: {
            x: { title: { display: true, text: "Year" } },
            yCutoff: {
              type: "linear",
              position: "left",
              title: { display: true, text: "Cut-off (AL score)" },
              ticks: { stepSize: 1 }
            },
            yCohort: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Sec 1 intake" },
              grid: { drawOnChartArea: false }
            }
          },
          plugins: {
            legend: { position: "bottom" },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const label = ctx.dataset.label || "";
                  const v = ctx.parsed.y;
                  if (v == null) return label;
                  if (ctx.dataset.yAxisID === "yCohort") {
                    const yr = ctx.chart.data.labels[ctx.dataIndex];
                    return `${yr} Sec 1 intake: ${v.toLocaleString()}`;
                  }
                  return `${label}: ${v.toFixed(0)}`;
                }
              }
            }
          }
        }
      };

      const yearsFromRows = Array.from(new Set(filteredRows.map((r) => r.year).filter((y) => y != null)));
      const yearsFromCohortIntake = Object.keys(psleCohortByYear).map((y) => parseInt(y, 10) + 1);
      const years = Array.from(new Set([...yearsFromRows, ...yearsFromCohortIntake]))
        .filter((y) => activeYears.has(y) && !excludedYears.has(y))
        .sort((a, b) => a - b);

      if (!years.length) return;

      const ctx = document.getElementById("trendChart").getContext("2d");
      const keysToPlot = [];
      if (activeGroups.has("pg1_max")) keysToPlot.push("pg1_max");
      if (activeGroups.has("pg2_max")) keysToPlot.push("pg2_max");
      if (activeGroups.has("pg3_max")) keysToPlot.push("pg3_max");
      if (activeGroups.has("ip_max"))  keysToPlot.push("ip_max");
      const combinedDatasets = keysToPlot.flatMap((k) => buildDatasetsForKey(k));

      const colorForIndex = (i) => `hsl(${(i * 47) % 360} 85% 45%)`;
      combinedDatasets.forEach((ds, i) => {
        const c = colorForIndex(i);
        ds.borderColor = c;
        ds.pointBackgroundColor = c;
        ds.pointBorderColor = c;
      });

      const allValues = combinedDatasets
        .flatMap((ds) => ds.data)
        .filter((v) => v != null);
      if (allValues.length) {
        const vmin = Math.min(...allValues);
        const vmax = Math.max(...allValues);
        const pad = 1;
        cfg.options.scales.yCutoff.min = Math.max(1, Math.floor(vmin - pad));
        cfg.options.scales.yCutoff.max = Math.ceil(vmax + pad);
      } else {
        cfg.options.scales.yCutoff.min = 4;
        cfg.options.scales.yCutoff.max = 30;
      }

      const cohortData = years.map((y) => psleCohortByYear[y - 1] ?? null);
      const intakeDataset = {
        label: "Sec 1 intake (students)",
        data: cohortData,
        yAxisID: "yCohort",
        tension: 0.25,
        borderDash: [4, 4],
        borderColor: "#334155",
        pointBackgroundColor: "#334155",
        borderWidth: 2,
        pointRadius: 4,
        pointHoverRadius: 6
      };

      chartInstance = new Chart(ctx, { ...cfg, data: { labels: years, datasets: combinedDatasets.concat([intakeDataset]) } });
    }

    function downloadFilteredCsv() {
      if (!filteredRows.length) return;

      const allHeaders = Array.from(new Set([...headers]));
      const rows = filteredRows.map((r) => {
        const obj = {};
        allHeaders.forEach((h) => {
          let v = r[h];
          obj[h] = v == null ? "" : v;
        });
        return obj;
      });

      const csv = Papa.unparse(rows, { columns: allHeaders });
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const now = new Date();
      const ts = now.toISOString().slice(0, 10);
      link.href = url;
      link.download = `filtered_psle_cutoff_${ts}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }



    function loadDefaultCsv() {
      setStatus("Loading data‚Ä¶");
      fetch("secondary_psle_cutoff.csv")
        .then((res) => {
          if (!res.ok) {
            throw new Error("Failed to fetch secondary_psle_cutoff.csv");
          }
          return res.text();
        })
        .then((text) => {
          const results = Papa.parse(text, {
            header: true,
            skipEmptyLines: true
          });
          const rows = results.data;
          if (!rows.length) {
            setStatus("No rows found in CSV");
            return;
          }

          headers = results.meta.fields || Object.keys(rows[0]);

          rawRows = rows.map((r) => {
            const row = { ...r };
            if (row.year !== undefined) {
              const yr = parseInt(row.year, 10);
              row.year = Number.isFinite(yr) ? yr : null;
            } else {
              row.year = null;
            }

            ["ip_max", "pg3_max", "pg2_max", "pg1_max"].forEach((k) => {
              if (row[k] !== undefined && row[k] !== null && row[k] !== "") {
                row[k] = toNumber(row[k]);
              }
            });

            // no aggregated cutoff stored; charts read per posting group
            return row;
          });

          setStatus(`Loaded ${rawRows.length} rows`);
          enableInputs();
          buildYearChips();
          filteredRows = [...rawRows];
          applySort();
          renderTable();
          updateMetrics();
          updateChart();
        })
        .catch((err) => {
          console.error(err);
          setStatus("Error loading CSV");
        });
    }

    document.addEventListener("DOMContentLoaded", loadDefaultCsv);

    searchInput.addEventListener("input", (e) => {
      searchTerm = e.target.value.trim().toLowerCase();
      applyFilter();
    });

    // removed CSV download button
    topFilterIP?.addEventListener("change", updateActiveGroups);
    topFilterPG3?.addEventListener("change", updateActiveGroups);
    topFilterPG2?.addEventListener("change", updateActiveGroups);
    topFilterPG1?.addEventListener("change", updateActiveGroups);
  </script>
</body>
</html>
